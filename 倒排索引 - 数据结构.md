### ByteBlockPool

这个类是一个基础类，作用是预分配一片连续的内存空间，从而将 byte 流写入到这片内存空间。通过该类可以高效管理内存，在倒排索引的实现中，该类被多次使用。

#### 关键成员变量

```java
  public static final int BYTE_BLOCK_SHIFT = 15;
  public static final int BYTE_BLOCK_SIZE = 1 << BYTE_BLOCK_SHIFT;
  public static final int BYTE_BLOCK_MASK = BYTE_BLOCK_SIZE - 1;

	/**
   * array of buffers currently used in the pool. Buffers are allocated if needed don't modify this
   * outside of this class.
   */
  public byte[][] buffers = new byte[10][];

  /** index into the buffers array pointing to the current buffer used as the head */
  private int bufferUpto = -1; // Which buffer we are upto
  /** Where we are in head buffer */
  public int byteUpto = BYTE_BLOCK_SIZE;

  /** Current head buffer */
  public byte[] buffer;
  /** Current head offset */
  public int byteOffset = -BYTE_BLOCK_SIZE;
```

下面按序介绍上述成员变量的含义。ByteBlockPool 逻辑结构如下：

![逻辑结构](/Users/xzy/Library/Application Support/typora-user-images/image-20221112235207233.png)

##### BYTE_BLOCK_*

BYTE_BLOCK_SIZE 表示 BLOCK  的大小。一个 BLOCK 的大小为 1 << 15 Byte，即 32KB，ByteBlockPool 由多个 BLOCK 组成。

BYTE_BLOCK_MASK BLOCK 掩码，方便快速定位偏移位置。

##### buffers

ByteBlockPool 真实的存储载体，一个二维数组用来表示多个 BLOCK，默认个数为 10，即默认存储容量为 320 KB。这里为什么要用二维数组来作为 Byte 容器，而不直接使用一维数组呢？可以思考下，假设当前容量不足，那么便要对容器进行扩容，我们知道数组是不能原地扩容的，需要重新分配足够大小的数组，然后将数据 copy 到新分配的数组中。对于一维数组来说，就是要 copy 数组中所有的原始数据，开销很大。而对于二维数组来说，数组中的元素就是一个个的一维数组（BLOCK），扩容时，按 BLOCK 粒度扩容，然后 copy 所有 BLOCK 的引用即指针到新数组即可，开销极大降低。

##### bufferUpto

当前正在使用的 buffer，即二维数组的当前行号。

##### byteUpto

当前 buffer 中，当前使用的 byte 位置，即二维数组的列号。

##### buffer

当前使用的 buffer。

##### byteOffset

当前行的再整个 Pool 中的起始偏移值。

#### 关键代码分析





